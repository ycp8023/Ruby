# lab7

rails server启动

首先确认rails命令的路径，在项目目录下执行 `which rails` 命令

```bash
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#
 
require 'rubygems'
 
version = ">= 0"
 
if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/
    version = $1
    ARGV.shift
  end
end
 
gem 'railties', version
load Gem.bin_path('railties', 'rails', version)
```

这个文件主要做了两件事：

- 导入railties这个gem
- load railties这个gem下的另一个rails脚本

执行Gem.bin_path，脚本内容

```bash
#!/usr/bin/env ruby
 
if File.exists?(File.join(File.expand_path('../../..', __FILE__), '.git'))
  railties_path = File.expand_path('../../lib', __FILE__)
  $:.unshift(railties_path)
end
require "rails/cli"
```

找到rails/cli.rb

```bash
require 'rails/app_rails_loader'
# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppRailsLoader.exec_app_rails
```

RailsDemoApp/bin/rails内容：

```bash
#!/usr/bin/env ruby
begin
  load File.expand_path("../spring", __FILE__)
rescue LoadError
end
APP_PATH = File.expand_path('../../config/application',  __FILE__)
require_relative '../config/boot'
require 'rails/commands'
```

这个文件作用：

- 定义了APP_PATH
- require config/boot文件，这个文件主要是进行bundle/setup，也就是检查Gemfile的内容
- require ‘rails/commands’

rails/commands.rb中代码：

```ruby
Rails::CommandsTasks.new(ARGV).run_command!(command)
```

run_command!方法代码：

```ruby
def run_command!(command)
  command = parse_command(command)
  if COMMAND_WHITELIST.include?(command)
    send(command)
  else
    write_error_message(command)
  end
end
```

其中调用了send(command),因为我们执行的rails server，就相当于这里又调用了server方法：

```ruby
def server
  set_application_directory!
  require_command!("server")

  Rails::Server.new.tap do |server|
    # We need to require application after the server sets environment,
    # otherwise the --environment option given to the server won't propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  end
end
```

- 调用了server.start方法，就相当于正式启动了server

rails application启动

执行`server.start`后，调用Rack::Server中的start方法：

```ruby
# rack/lib/rack/server.rb
def start &blk
  ......

  check_pid! if options[:pid]

  # Touch the wrapped app, so that the config.ru is loaded before
  # daemonization (i.e. before chdir, etc).
  # 关键点
  wrapped_app

  daemonize_app if options[:daemonize]

  write_pid if options[:pid]

  trap(:INT) do
    if server.respond_to?(:shutdown)
      server.shutdown
    else
      exit
    end
  end

  # 关键点
  server.run wrapped_app, options, &blk
end
```

执行`server run warpped_app`

```ruby
# rack/lib/rack/server.rb
def wrapped_app
  @wrapped_app ||= build_app app
end
```

其中的`app`就是执行config.ru

```ruby
# rack/lib/rack/builder.rb
def self.new_from_string(builder_script, file="(rackup)")
  # 执行了config.ru文件, 然后调用to_app
  eval "Rack::Builder.new {\n" + builder_script + "\n}.to_app",
    TOPLEVEL_BINDING, file, 0
end
```

config.ru文件内容：

```ruby
# RailsDemoApp/config.ru
# This file is used by Rack-based servers to start the application.
require ::File.expand_path('../config/environment',  __FILE__)
run Rails.application
```

config.ru涉及到以下步骤

1.Load config/environments/ENV.rb

```ruby
# rails/railties/lib/rails/engine.rb
# 这个就是启动流程中的 5) Load config/environments/ENV.rb, 特别注意这里用了before
initializer :load_environment_config, before: :load_environment_hook, group: :all do
  paths["config/environments"].existent.each do |environment|
    require environment
  end
end
```

2.Run config.before_initialize callbacks

```ruby
# rails/railties/lib/rails/application/bootstrap.rb
initializer :bootstrap_hook, group: :all do |app|
  ActiveSupport.run_load_hooks(:before_initialize, app)
end
```

3.Rails应用config目录下的initializers执行的源码位置

```ruby
# rails/railties/lib/rails/engine.rb
# 这里就是config目录下的initializers执行的位置
initializer :load_config_initializers do
  config.paths["config/initializers"].existent.sort.each do |initializer|
    load_config_initializer(initializer)
  end
end
```

```ruby
# rails/railties/lib/rails/application/finisher.rb
initializer :build_middleware_stack do
  build_middleware_stack
end

# This needs to happen before eager load so it happens
# in exactly the same point regardless of config.cache_classes
# 9) run to_prepare callbacks
initializer :run_prepare_callbacks do
  ActionDispatch::Reloader.prepare!
end
```

4.Run config.before_eager_load and eager_load! if eager_load is true

```ruby
# rails/railties/lib/rails/application/finisher.rb
initializer :eager_load! do
  if config.eager_load
    ActiveSupport.run_load_hooks(:before_eager_load, self)
    config.eager_load_namespaces.each(&:eager_load!)
  end
end
```

5.Run config.after_initialize callbacks

```ruby
# rails/railties/lib/rails/application/finisher.rb
# All initialization is done, including eager loading in production
initializer :finisher_hook do
  ActiveSupport.run_load_hooks(:after_initialize, self)
end
```

在environment.rb文件中，调用了`Rails.application.initialize!`，接下来的步骤都是在该方法中完成的。

```ruby
# RailsDemoApp/config/environment.rb
# Load the Rails application.
require File.expand_path('../application', __FILE__)

# Initialize the Rails application.
Rails.application.initialize!
```

Rails.application.initialize!代码如下：

```ruby
# rails/railties/lib/rails/application.rb
# Initialize the application passing the given group. By default, the
# group is :default
def initialize!(group=:default) #:nodoc:
  raise "Application has been already initialized." if @initialized
  # 执行了所有的注册的initializers
  run_initializers(group, self)
  @initialized = true
  self
end
```

至此，Rails App的启动流程就完成了。